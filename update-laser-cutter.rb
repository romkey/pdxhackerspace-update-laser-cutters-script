#!/usr/bin/env ruby
# frozen_string_literal: true

require "json"
require "net/http"
require "optparse"
require "securerandom"
require "uri"

VERBS = ["update", "users"].freeze

def usage
  $stderr.puts "Usage: ACCESS_TOKEN=USER:PASSWORD #{$PROGRAM_NAME} <verb> [args]"
  $stderr.puts "       #{$PROGRAM_NAME} --actions"
  exit 1
end

list_actions = false
OptionParser.new do |opts|
  opts.on("--actions", "List all available actions") do
    list_actions = true
  end
end.parse!(ARGV)

if list_actions
  puts VERBS.join("\n")
  exit 0
end

verb = ARGV.shift
usage unless verb && !verb.strip.empty?
unless VERBS.include?(verb)
  $stderr.puts "Unknown verb: #{verb}"
  usage
end

host = ARGV.shift if verb == "update"
usage if verb == "update" && (host.nil? || host.strip.empty?)

access_token = ENV["ACCESS_TOKEN"]
if verb == "update" && (access_token.nil? || access_token.strip.empty?)
  $stderr.puts "ACCESS_TOKEN is required"
  exit 1
end

input = $stdin.read
if input.nil? || input.strip.empty?
  $stderr.puts "STDIN must contain a JSON array of users"
  exit 1
end

begin
  users = JSON.parse(input)
rescue JSON::ParserError => e
  $stderr.puts "Invalid JSON input: #{e.message}"
  exit 1
end

unless users.is_a?(Array)
  $stderr.puts "Expected JSON array of user records"
  exit 1
end

# Rewrite user records into the laser cutter access list format.
lines = []
lines << "# This file is automatically generated"
override_key = ENV["OVERRIDE_KEY"]
lines << override_key if override_key && !override_key.strip.empty?

users.each do |user|
  permissions = user["permissions"] || []
  next unless permissions.include?("Laser")

  rfids = user["rfids"] || []
  next if rfids.empty?

  facility, uid = rfids[0].split(",", 2)
  next if facility.nil? || uid.nil?

  bits = (1 << 25) | (facility.to_i << 17) | (uid.to_i << 1)
  bit_string = format("%026b", bits)

  left_parity = 1
  right_parity = 1
  12.times do |index|
    left_parity ^= bit_string[index + 1].to_i
    right_parity ^= bit_string[index + 13].to_i
  end

  bit_string[0] = "0" if left_parity == 1
  bit_string[25] = "1" if right_parity == 1

  line = format("%07x:26 %s", bit_string.to_i(2), user["name"])
  lines << line
end

payload = lines.join("\n") + "\n"

if verb == "users"
  $stdout.write(payload)
  exit 0
end

username, password = access_token.split(":", 2)
if username.nil? || username.empty? || password.nil? || password.empty?
  $stderr.puts "ACCESS_TOKEN must be in USER:PASSWORD format"
  exit 1
end

uri = URI.parse("http://#{host}/edit")
boundary = "----RubyFormBoundary#{SecureRandom.hex(12)}"

body = +""
body << "--#{boundary}\r\n"
body << "Content-Disposition: form-data; name=\"f\"; filename=\"/auth.txt\"\r\n"
body << "Content-Type: text/plain\r\n"
body << "\r\n"
body << payload
body << "\r\n"
body << "--#{boundary}--\r\n"

request = Net::HTTP::Post.new(uri)
request.basic_auth(username, password)
request["Content-Type"] = "multipart/form-data; boundary=#{boundary}"
request.body = body

response = Net::HTTP.start(uri.hostname, uri.port) do |http|
  http.request(request)
end

unless response.is_a?(Net::HTTPSuccess)
  $stderr.puts "HTTP upload failed: #{response.code} #{response.body}"
  exit 1
end

puts "Updated laser cutter users for #{host}"
